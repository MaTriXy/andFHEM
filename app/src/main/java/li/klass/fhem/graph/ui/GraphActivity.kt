/*
 * AndFHEM - Open Source Android application to control a FHEM home automation
 * server.
 *
 * Copyright (c) 2011, Matthias Klass or third-party contributors as
 * indicated by the @author tags or express copyright attribution
 * statements applied by the authors.  All third-party contributions are
 * distributed under license by Red Hat Inc.
 *
 * This copyrighted material is made available to anyone wishing to use, modify,
 * copy, or redistribute it subject to the terms and conditions of the GNU GENERAL PUBLIC LICENSE, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU GENERAL PUBLIC LICENSE
 * for more details.
 *
 * You should have received a copy of the GNU GENERAL PUBLIC LICENSE
 * along with this distribution; if not, write to:
 *   Free Software Foundation, Inc.
 *   51 Franklin Street, Fifth Floor
 *   Boston, MA  02110-1301  USA
 */

@file:Suppress("DEPRECATION")

package li.klass.fhem.graph.ui

import android.app.Activity
import android.app.Dialog
import android.app.ProgressDialog
import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.view.Menu
import android.view.MenuItem
import androidx.appcompat.app.ActionBar
import androidx.appcompat.app.AppCompatActivity
import com.github.mikephil.charting.components.Description
import com.github.mikephil.charting.components.XAxis
import com.github.mikephil.charting.components.YAxis
import com.github.mikephil.charting.data.Entry
import com.github.mikephil.charting.data.LineData
import com.github.mikephil.charting.data.LineDataSet
import com.github.mikephil.charting.formatter.ValueFormatter
import com.github.mikephil.charting.interfaces.datasets.ILineDataSet
import kotlinx.coroutines.*
import li.klass.fhem.AndFHEMApplication
import li.klass.fhem.R
import li.klass.fhem.activities.core.Updateable
import li.klass.fhem.constants.BundleExtraKeys
import li.klass.fhem.databinding.ChartBinding
import li.klass.fhem.devices.ui.ChartMarkerView
import li.klass.fhem.domain.core.FhemDevice
import li.klass.fhem.graph.backend.GraphEntry
import li.klass.fhem.graph.backend.GraphService
import li.klass.fhem.graph.backend.gplot.GPlotSeries
import li.klass.fhem.graph.backend.gplot.Range
import li.klass.fhem.graph.backend.gplot.SvgGraphDefinition
import li.klass.fhem.update.backend.DeviceListService
import li.klass.fhem.util.DateFormatUtil.ANDFHEM_DATE_TIME_FORMAT
import li.klass.fhem.util.DisplayUtil
import li.klass.fhem.util.resolveColor
import org.joda.time.DateTime
import org.joda.time.format.DateTimeFormat
import javax.inject.Inject

class GraphActivity : AppCompatActivity(), Updateable {

    private lateinit var deviceName: String
    private lateinit var svgGraphDefinition: SvgGraphDefinition
    private var startDate: DateTime? = null
    private var endDate: DateTime? = null
    private var connectionId: String? = null

    @Inject
    lateinit var deviceListService: DeviceListService

    @Inject
    lateinit var graphService: GraphService

    private lateinit var binding: ChartBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ChartBinding.inflate(layoutInflater)
        setContentView(binding.root)

        (application as AndFHEMApplication).daggerComponent.inject(this)

        if (savedInstanceState != null && savedInstanceState.containsKey(BundleExtraKeys.START_DATE)) {
            startDate = savedInstanceState.getSerializable(BundleExtraKeys.START_DATE) as DateTime?
        }
        if (savedInstanceState != null && savedInstanceState.containsKey(BundleExtraKeys.END_DATE)) {
            endDate = savedInstanceState.getSerializable(BundleExtraKeys.END_DATE) as DateTime?
        }

        val extras = intent.extras ?: return
        deviceName = extras.getString(BundleExtraKeys.DEVICE_NAME)!!
        connectionId = extras.getString(BundleExtraKeys.CONNECTION_ID)

        svgGraphDefinition =
            extras.getSerializable(BundleExtraKeys.DEVICE_GRAPH_DEFINITION) as SvgGraphDefinition


        supportActionBar!!.navigationMode = ActionBar.NAVIGATION_MODE_STANDARD

        GlobalScope.launch(Dispatchers.Main) {
            update(false)
        }
    }

    override suspend fun update(refresh: Boolean) {
        val name = deviceName
        coroutineScope {
            withContext(Dispatchers.IO) {
                deviceListService.getDeviceForName(name, connectionId)
            }?.let {
                readDataAndCreateChart(it)
            }
        }
    }

    /**
     * Reads all the charting data for a given date and the column specifications set as attribute.
     * @param device    concerned device
     */
    private suspend fun readDataAndCreateChart(device: FhemDevice) {
        val myContext = this
        coroutineScope {
            showDialog(DIALOG_EXECUTING)
            val result = withContext(Dispatchers.IO) {
                graphService.getGraphData(
                    device,
                    connectionId,
                    svgGraphDefinition,
                    startDate,
                    endDate,
                    myContext
                )
            }
            dismissDialog(DIALOG_EXECUTING)

            startDate = result.interval.start
            endDate = result.interval.end
            createChart(device, result.data)
        }
    }

    /**
     * Actually creates the charting view by using the newly read charting data.

     * @param device    concerned device
     * *
     * @param graphData used graph data
     */
    private fun createChart(device: FhemDevice, graphData: Map<GPlotSeries, List<GraphEntry>>) {

        val activity = this
        val themeTextColor = theme.resolveColor(android.R.attr.textColorPrimary)

        val processedData = handleDiscreteValues(graphData)
        val lineData = createLineDataFor(processedData)
        val title = if (DisplayUtil.getWidthInDP(applicationContext) < 500) {
            device.aliasOrName + "\n\r" +
                    DATE_TIME_FORMATTER.print(startDate) + " - " + DATE_TIME_FORMATTER.print(endDate)
        } else {
            device.aliasOrName + " " +
                    DATE_TIME_FORMATTER.print(startDate) + " - " + DATE_TIME_FORMATTER.print(endDate)
        }
        supportActionBar!!.title = title

        binding.chart.apply {
            xAxis.apply {
                valueFormatter = object : ValueFormatter() {
                    override fun getFormattedValue(value: Float): String =
                        ANDFHEM_DATE_TIME_FORMAT.print(value.toLong())
                }
                labelRotationAngle = 300f
                val labelCount = DisplayUtil.getWidthInDP(applicationContext) / 150
                setLabelCount(if (labelCount < 2) 2 else labelCount, true)
                position = XAxis.XAxisPosition.BOTTOM
                textColor = themeTextColor
            }
            axisLeft.textColor = themeTextColor
            axisRight.textColor = themeTextColor
            legend.textColor = themeTextColor

            val plotDefinition = svgGraphDefinition.plotDefinition
            setRangeFor(plotDefinition.leftAxis.range, axisLeft)
            setRangeFor(plotDefinition.rightAxis.range, axisRight)

            description = Description().apply { text = "" }
            data = lineData
            marker = ChartMarkerView(activity)
            setNoDataText(getString(R.string.noGraphEntries))

            animateX(200)
        }
    }

    private fun setRangeFor(axisRange: Range?, axis: YAxis) {
        if (axisRange != null) {
            if (axisRange.lowerInclusive != null) {
                axis.axisMinimum = axisRange.lowerInclusive
            }
            if (axisRange.upperInclusive != null) {
                axis.axisMaximum = axisRange.upperInclusive
            }
        }
    }

    private fun handleDiscreteValues(graphData: Map<GPlotSeries, List<GraphEntry>>): Map<GPlotSeries, List<GraphEntry>> {
        return graphData.mapValues { (key, values) ->
            if (!isDiscreteSeries(key)) {
                values
            } else handleDiscreteValue(key, values)
        }
    }

    private fun handleDiscreteValue(
        gPlotSeries: GPlotSeries,
        values: List<GraphEntry>
    ): List<GraphEntry> {
        if (!isDiscreteSeries(gPlotSeries)) {
            return values
        }

        var previousValue = -1f
        val newData = mutableListOf<GraphEntry>()

        for (graphEntry in values) {
            val date = graphEntry.date
            val value = graphEntry.value

            if (previousValue == -1f) {
                previousValue = value
            }

            newData.add(GraphEntry(date.minusMillis(1), previousValue))
            newData.add(GraphEntry(date, value))
            newData.add(GraphEntry(date.plusMillis(1), value))

            previousValue = value
        }

        return newData
    }

    private fun isDiscreteSeries(plotSeries: GPlotSeries): Boolean {
        val lineType = plotSeries.viewSpec.lineType
        return lineType == GPlotSeries.LineType.STEPS || lineType == GPlotSeries.LineType.FSTEPS || lineType == GPlotSeries.LineType.HISTEPS
    }

    private fun createLineDataFor(graphData: Map<GPlotSeries, List<GraphEntry>>): LineData? {
        val lineDataItems = graphData
            .filter { it.value.isNotEmpty() }
            .map { lineDataSetFrom(it) }.toList()
        return if (lineDataItems.isEmpty()) null else LineData(lineDataItems)
    }

    private fun lineDataSetFrom(entry: Map.Entry<GPlotSeries, List<GraphEntry>>): ILineDataSet {
        val series = entry.key
        val yEntries = entry.value.map { Entry(it.date.millis.toFloat(), it.value) }.toList()

        return LineDataSet(yEntries, series.viewSpec.title).apply {
            axisDependency = if (series.viewSpec.axis == GPlotSeries.Axis.LEFT)
                YAxis.AxisDependency.LEFT
            else
                YAxis.AxisDependency.RIGHT

            val seriesColor =
                theme.resolveColor(
                    (series.viewSpec.color
                        ?: GPlotSeries.SeriesColor.RED).colorAttribute
                )
            color = seriesColor
            setCircleColor(seriesColor)
            fillColor = seriesColor
            setDrawCircles(false)
            setDrawValues(false)
            lineWidth = series.viewSpec.lineWidth

            when (series.viewSpec.seriesType) {
                GPlotSeries.SeriesType.FILL -> setDrawFilled(true)
                GPlotSeries.SeriesType.DOT -> enableDashedLine(3f, 2f, 1f)
                else -> {
                }
            }

            when (series.viewSpec.lineType) {
                GPlotSeries.LineType.POINTS -> enableDashedLine(3f, 2f, 1f)
                else -> {
                }
            }

            if (isDiscreteSeries(series)) {
                mode = LineDataSet.Mode.STEPPED
            }
        }
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        menuInflater.inflate(R.menu.graph_menu, menu)
        return super.onCreateOptionsMenu(menu)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.menu_changeStartEndDate -> {
                startActivityForResult(
                    Intent(this, ChartingDateSelectionActivity::class.java)
                        .putExtra(BundleExtraKeys.DEVICE_NAME, deviceName)
                        .putExtra(BundleExtraKeys.START_DATE, startDate)
                        .putExtra(BundleExtraKeys.END_DATE, endDate), REQUEST_TIME_CHANGE
                )
                return true
            }
        }

        return super.onOptionsItemSelected(item)
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, resultIntent: Intent?) {
        super.onActivityResult(requestCode, resultCode, resultIntent)

        if (resultIntent != null && resultCode == Activity.RESULT_OK) {
            val bundle = resultIntent.extras ?: return
            when (requestCode) {
                REQUEST_TIME_CHANGE -> {
                    startDate = bundle.getSerializable(BundleExtraKeys.START_DATE) as DateTime
                    endDate = bundle.getSerializable(BundleExtraKeys.END_DATE) as DateTime
                    GlobalScope.launch(Dispatchers.Main) {
                        update(false)
                    }
                }
            }
        }
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putSerializable(BundleExtraKeys.START_DATE, startDate)
        outState.putSerializable(BundleExtraKeys.END_DATE, endDate)
    }

    @Suppress("OverridingDeprecatedMember")
    override fun onCreateDialog(id: Int): Dialog? {
        super.onCreateDialog(id)

        when (id) {
            DIALOG_EXECUTING -> return ProgressDialog.show(
                this,
                "",
                resources.getString(R.string.executing)
            )
        }
        return null
    }

    companion object {

        private const val REQUEST_TIME_CHANGE = 1
        private const val DIALOG_EXECUTING = 2

        private val DATE_TIME_FORMATTER = DateTimeFormat.forPattern("yyyy-MM-dd")

        /**
         * Jumps to the charting activity.

         * @param context         calling intent
         * *
         * @param device          concerned device
         * *
         * @param connectionId    connection ID
         * *
         * @param graphDefinition series descriptions each representing one series in the resulting chart
         */
        fun showChart(
            context: Context,
            device: FhemDevice,
            connectionId: String?,
            graphDefinition: SvgGraphDefinition
        ) {
            context.startActivity(
                Intent(context, GraphActivity::class.java)
                    .putExtra(BundleExtraKeys.DEVICE_NAME, device.name)
                    .putExtra(BundleExtraKeys.CONNECTION_ID, connectionId)
                    .putExtra(BundleExtraKeys.DEVICE_GRAPH_DEFINITION, graphDefinition)
            )
        }
    }
}
